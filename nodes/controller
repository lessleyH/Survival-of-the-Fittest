#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.

import random
import rospy
import random
from ant_foraging.srv import InitNest, InitNestResponse, AntStart, AntStartResponse, EndRound

'''
Initializations	
Keeps round/loops through things
Sends message to nest that round has ended
Send food locations to nest
'''

class Controller():
    def __init__(self, rounds):
        rospy.loginfo("In init of controller") 
        self.rounds = rounds
        self.init_nest = rospy.Service('init_nest', InitNest, self.handle_init_nest)
        self.start_simulation()
        rospy.loginfo("end of init in Controller node") 

    def start_simulation(self):
        rospy.loginfo("Controller: Starting Simulation") 
        for i in range(self.rounds):
            rospy.loginfo("Controller: Round num:") 
            rospy.loginfo(i) 
            for ant in range(30):
                rospy.loginfo("Controller: The ant we are on") 
                rospy.loginfo(ant) 
                self.ant_start_client(ant)
            self.end_round_client()

    def ant_start_client(self, num):
            rospy.wait_for_service('/robot_{}/ant_start'.format(num))
            try:
                ant_start = rospy.ServiceProxy('/robot_{}/ant_start'.format(num), AntStart)
                resp = ant_start(num)
                return resp.b
            except rospy.ServiceException as e:
                print("Service call failed: %s"%e)
        

    def end_round_client(self):
        rospy.loginfo("Controller: End Round client") 
        rospy.wait_for_service('end_round')
        try:
            end_round = rospy.ServiceProxy('end_round', EndRound)
            resp = end_round()
            rospy.loginfo("Amount of Food After round is:") 
            rospy.loginfo(resp.b)
        except rospy.ServiceException as e:
            print("Service call failed: %s"%e)


    # foodType 0 = large and rare
    # foodType 1 = small and common
    def init_nest_variables(self, foodType):
        rospy.loginfo("Controller: init nest variables") 
        i = random.randint(0,39)
        j = random.randint(0,39)

        points = []
        num = 0
        amt = 0

        if foodType == 0:
            num = 45
            amt = 1000
        else:
            num = 900
            amt = 29
        
        food_loc = [ [0] * 40 for i in range(40)]
        food_loc[i][j] = 1

        for d in range(num):
            rand_x = random.randint(0,39)
            rand_y = random.randint(0,39)
            
            if food_loc[rand_x][rand_y] != 1:
                points.append((rand_x, rand_y))
                food_loc[rand_x][rand_y] = 1

        # x,y,amt x,y,amt
        foods = ""
        for point in points:
            foods += str(point[0]) + "," + str(point[1]) + "," + str(amt) + " "

        foods = foods[:-1]

        return (i,j,foods)


    def handle_init_nest(self, req):
        rospy.loginfo("Controller: Handling init nests") 

        checks = self.init_nest_variables(1)
        response = InitNestResponse()
        response.i = checks[0]
        response.j = checks[1]
        response.foods = checks[2]
        return response

def main():
    """Main function."""
    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the simple motion.
    controller = Controller(100)
    
    rospy.spin()
    # If interrupted, send a stop command.
    rospy.on_shutdown(controller.stop)


if __name__ == "__main__":
    """Run the main function."""
    rospy.init_node('Controller') 
    rospy.loginfo("Controller node init") 
    try:
        main()
    except rospy.ROSInterruptException:
        pass

