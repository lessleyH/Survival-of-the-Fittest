#!/usr/bin/env python
#The line above is important so that this file is interpreted with Python when running it.
import numpy as np
import random

# import of relevant libraries.
import rospy # module for ROS APIs
from geometry_msgs.msg import PoseWithCovarianceStamped, Point  # Msg of the position of the robot
from std_msgs.msg import Float64 
# http://docs.ros.org/en/api/geometry_msgs/html/msg/PoseWithCovarianceStamped.html
from nav_msgs.msg import OccupancyGrid, GridCells, Odometry  # Msg of the path
from service_node.srv import*

class Ant():
    def __init__(self, sigma_1, signma_2, mu):
        self._map_sub = rospy.Subscriber('/map', OccupancyGrid, self.map_callback, queue_size=1)
        self._pos_sub = rospy.Subscriber('/amcl_pose', PoseWithCovarianceStamped, self.pos_callback, queue_size=1)
        self._cmd_pub = rospy.Publisher('/cells', GridCells, queue_size=1)
        self._odo_pub = rospy.Publisher('/odom', Odometry)

        self.pos = None  # type: Pos  
        self.ishome = None # type: Pos. The nest Position # TODO: This could just be the they first spawn in instead of hardcoding
        
        self.flip_dir = False # type: Boolean. Turns robot 180  
        
        self.hasfood = False # type: Boolean. Keeps track of food 
        self.removed = False # type: Boolean. Keeps track of whether the robot has been stopped or not
        self.out_of_bounds = False

        self.pheremones = None#TODO: Deposited 
        self.sigma_1 = sigma_1 
        self.sigma_2 = signma_2
        self.mu = mu # Dictates how much ant favors movement towarsds empty cells 
        self.potential_coordinates = None

    def randomize_direction(self): #TODO: Fix up service call(client)
        direction = self.pos
        rospy.wait_for_service('whatever_this_service_is_named') #TODO: Change the name to whatever the service is called

        try: 
            nest_update = rospy.ServiceProxy('current_grid_space', CurrentGridSpace)#TODO: Change to actual name
            resp1 = nest_update(self.pos) 
            self.removed = resp1.removed
            self.pheremones = resp1.pheremones
            self.potential_coordinates = resp1.coord 

        except rospy.ServiceException as e:
            print("Service call failed in the randomize direction function: %s"%e)


        left_loc = self.potential_coordinates[0]
        front_loc = self.potential_coordinates[1]
        right_loc = self.potential_coordinates[2]

        #Update the Pheremones 
        lp = self.pheremones[0]
        fp = self.pheremones[1]
        rp = self.pheremones[2]

        p_m = 0.5 * (1 + np.tanh((lp + fp + rp)/100 - 1))
        if np.random.choice(2, 1, p=[1-p_m,p_m]):
            c = (self.mu + lp)**2 + (self.mu + fp)**2 + (self.mu + rp)**2
            p_left = 1/c * (self.mu + lp)**2
            p_front = 1/c * (self.mu + fp)**2
            p_right = 1/c * (self.mu + rp)**2
            
        next_loc = np.random.choice(["left_loc","right_loc","front_loc"], 1, p=[p_left,p_right,p_front])
        if next_loc == "left_loc":
            direction = left_loc
        elif next_loc == "front_loc":
            direction = front_loc
        elif next_loc == "right_loc":
            direction = right_loc

        return direction

    def move(self): # send to nest get the center coord. do the physical calc for moving the robot there
        # if you are out of bounds then stop moving
        # check if it has food or home
        dir = self.randomize_direction()
        self.move_helper(dir)
  
        rospy.wait_for_service('nest_update') #TODO: Change the name to whatever the service is called
        try: 
            nest_update = rospy.ServiceProxy('nest_update', NestUpdate)#TODO: Change to actual name
            resp2 = nest_update(self.pos) 
            self.removed = resp2.removed
            self.hasfood = resp2.pheremones
            self.ishome = resp2.nest

        except rospy.ServiceException as e:
            print("Service call failed in the randomize direction function: %s"%e)

        if self.removed: 
            self.stop()

        else:
            if self.hasfood:
                self.flip_dir = True 
                self.mu -= 0.3 # threshold for pheremones is stronger 
                #TODO: Figure out how to make them come back
                        

            if self.ishome:
                self.hasfood = False
                self.removed = True
                rospy.loginfo("Hi, made it back!")


    def move_helper(self, direction):
        "This is where I will actually move the robot. Should update self.pos before sending it to the server"
        print(42)

    #pos and from the center 
    def pos_callback(self, pose):
        """:type pose: PoseWithCovarianceStamped"""
        if None in [self.map, self.measurements]:
            return

        if self.pos != Pos(pose.pose.pose.position.x, pose.pose.pose.position.y):
            print("pose received")
            self.pos = Pos(pose.pose.pose.position.x, pose.pose.pose.position.y)

            self.map_pos = Pos(int(round((self.pos.x - self.map.info.origin.position.x) / self.map.info.resolution)),
                               int(round((self.pos.y - self.map.info.origin.position.y) / self.map.info.resolution)))

            m = int(round(MEASUREMENT_RADIUS / self.map.info.resolution))
            for x, y in itertools.product(xrange(self.map_pos.x - m, self.map_pos.x + m),
                                          xrange(self.map_pos.y - m, self.map_pos.y + m)):
                try:
                    self.measurements[x][y] = 0
                except IndexError:
                    pass

            self.calc_grid()

    def _callback(self, msg):
        self.msg_from_nest = msg.data
        rospy.loginfo("Hi, this is from an ant: {}".format(self.msg_to_nest))
        self._chat_pub.publish(self.msg_to_nest)


    def map_callback(self, cb_map):
        """:type cb_map: OccupancyGrid"""
        print("map received")
        self.map = cb_map
        costmap = [list(l) for l in zip(*[self.map.data[y * self.map.info.width:(y + 1) * self.map.info.width]
                                          for y in xrange(self.map.info.height)])]

        for x in xrange(len(costmap)):  # type: int
            for y in itertools.chain(xrange(len(costmap[x])), reversed(xrange(len(costmap[x])))):  # type: int
                try:
                    for i, j in itertools.product(*[[0, 1, -1]] * 2):
                        costmap[x + i][y + j] = max(costmap[x + i][y + j], costmap[x][y] - 1)
                except IndexError:
                    pass
        for y in xrange(len(costmap[0])):  # type: int
            for x in itertools.chain(xrange(len(costmap)), reversed(xrange(len(costmap)))):  # type: int
                try:
                    for i, j in itertools.product(*[[0, 1, -1]] * 2):
                        costmap[x + i][y + j] = max(costmap[x + i][y + j], costmap[x][y] - 1)
                except IndexError:
                    pass

        self.costmap = costmap
        self.measurements = [[-1] * self.map.info.height for _ in xrange(self.map.info.width)]
        self.calc_grid()


    def send(self):
        if self.grid is not None:
            print("grid sent, len:", len(self.grid.cells))
            self.coverage_pub.publish(self.grid)

    def stop(self):
        """Stop the robot."""
        twist_msg = Twist()
        self.removed = True
        self._cmd_pub.publish(twist_msg)

def main():
    """Main function."""
    rospy.init_node('Ant')
       
    # Sleep for a few seconds to wait for the registration.
    rospy.sleep(2)

    # Initialization of the class for the simple motion.
    ant_bot = Ant()

    # If interrupted, send a stop command.
    rospy.on_shutdown(ant_bot.stop)

if __name__ == "__main__":
    """Run the main function."""
    rospy.init_node('Ant')
    try:
        main()
    except rospy.ROSInterruptException:
        rospy.logerr("ROS node interrupted.")